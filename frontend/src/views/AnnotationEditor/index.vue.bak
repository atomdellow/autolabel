<template>  <div class="annotation-editor-view">
    <BreadcrumbNav>
      <router-link :to="{ name: 'Dashboard' }">Dashboard</router-link> &gt;
      <router-link :to="{ name: 'ProjectDetail', params: { projectId: projectId } }">Project: {{ projectStore.currentProject?.name }}</router-link> &gt;
      <span>Annotate: {{ imageStore.getImageById(imageId)?.name }}</span>
    </BreadcrumbNav>    
    <div class="editor-layout">
      <Toolbar 
        :annotation-draw="annotationDraw"
        :zoom-pan="zoomPan"
        :annotation-history="annotationHistory"
        :annotation-store="annotationStore"
        :detection="detection"
      />
      <AnnotationCanvas 
        ref="canvasComponent"
        :image-url="imageUrl"
        :zoom-pan="zoomPan"
        :annotation-draw="annotationDraw"
        :annotation-edit="annotationEdit"
        :canvas-coordinates="canvasCoordinates"
        @image-loaded="onImageLoaded"
        @image-load-error="onImageLoadError"
        @redraw-requested="redrawCanvas"
      />

      <div class="side-panel">
        <ClassesPanel 
          :project-store="projectStore"
          :annotation-selection="annotationSelection"
          :get-color-for-class="getColorForClass"
          @class-selected="selectClass"
        />
        
        <LayersPanel 
          :annotation-store="annotationStore"
          :annotation-selection="annotationSelection"
          :annotation-edit="annotationEdit"
          :annotation-history="annotationHistory"
          :get-color-for-class="getColorForClass"
          @highlight-annotation="highlightAnnotation"
          @unhighlight-annotation="unhighlightAnnotation"
          @delete-annotation="deleteExistingAnnotation"
          @delete-selected-annotations="deleteSelectedAnnotations"
        />
          <RawDataPanel 
          :annotation-store="annotationStore"
          :image-store="imageStore"
          :image-id="imageId"
          @import-complete="onImportComplete"
        />
          <TagsPanel 
          :tag-management="tagManagement"
          :image-id="imageId"
        />
        
        <DetectionPanel 
          :detection="detection"
          :image-store="imageStore"
        />
      </div>
    </div>

    <ClassModal 
      :is-visible="showClassModal"
      :initial-class-name="currentClassName"
      :project-store="projectStore"
      :get-color-for-class="getColorForClass"
      @confirm="confirmClassInput"
      @cancel="cancelClassInput"
    />
  </div>
</template>

<script setup>
// Import necessary functions
import { ref, computed, onMounted, onUnmounted, watch, nextTick } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { useToast } from 'vue-toastification';
import './styles/index.css';

// Import our stores
import { useProjectStore } from '../../store/projectStore';
import { useImageStore } from '../../store/imageStore';
import { useAnnotationStore } from '../../store/annotationStore';
import { getImageUrl } from '../../services/imageService';
import { isValidImageUrl, extractFilename, isValidPath, constructImageUrl } from '../../utils/imageUtils';

// Import components
import Toolbar from './components/Toolbar.vue';
import AnnotationCanvas from './components/AnnotationCanvas.vue';
import ClassesPanel from './components/ClassesPanel.vue';
import LayersPanel from './components/LayersPanel.vue';
import RawDataPanel from './components/RawDataPanel.vue';
import TagsPanel from './components/TagsPanel.vue';
import DetectionPanel from './components/DetectionPanel.vue';
import ClassModal from './components/ClassModal.vue';
import BreadcrumbNav from '../../components/BreadcrumbNav.vue';

// Import utilities
import { transformCoordinates } from '../../utils/annotationUtils';

// Import composables
import { useAnnotationDraw } from './composables/useAnnotationDraw';
import { useAnnotationEdit } from './composables/useAnnotationEdit';
import { useAnnotationHistory } from './composables/useAnnotationHistory';
import { useAnnotationSelection } from './composables/useAnnotationSelection';
import { useCanvasCoordinates } from './composables/useCanvasCoordinates';
import { useDetection } from './composables/useDetection';
import { useTagManagement } from './composables/useTagManagement';
import { useZoomPan } from './composables/useZoomPan';

// Component state
const route = useRoute();
const router = useRouter();
const toast = useToast();
const projectStore = useProjectStore();
const imageStore = useImageStore();
const annotationStore = useAnnotationStore();

// Get route params
const projectId = ref(route.params.projectId);
const imageId = ref(route.params.imageId);

// Canvas refs and state
const canvasComponent = ref(null);
const imageUrl = ref('');

// Function to redraw the canvas (will be passed to other composables)
function redrawCanvas() {
  // Check if we have initialized the composables yet
  if (!annotationDraw) {
    console.warn('Cannot redraw: annotationDraw not initialized yet');
    return;
  }
  
  // Only proceed if we have a context
  if (!annotationDraw?.canvasContext?.value) {
    console.warn('Cannot redraw: canvas context is null');
    // Retry after a short delay if context is null
    setTimeout(() => {
      if (annotationDraw?.canvasContext?.value) {
        console.log('Canvas context now available, redrawing...');
        redrawCanvas();
      }
    }, 100);
    return;
  }
    try {
    // Get canvas and its context
    const canvas = annotationDraw.canvasContext.value.canvas;
    const ctx = annotationDraw.canvasContext.value;
    
    // Check if canvas is valid
    if (!canvas || canvas.width === 0 || canvas.height === 0) {
      console.warn('Cannot redraw: invalid canvas dimensions');
      return;
    }
    
    // Force a repaint/reflow to ensure canvas is ready
    void canvas.offsetHeight;
    
    // Clear the canvas first
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw current annotations from the store
    // This will be called once per redraw, preventing infinite recursion
    const annotations = annotationStore.currentAnnotations;
      
    // Also check if we have valid zoom level
    const currentZoomLevel = zoomPan?.zoomLevel?.value || 1;
    const currentPanOffset = zoomPan?.panOffset?.value || { x: 0, y: 0 };
    console.log(`Redrawing canvas with zoom level: ${currentZoomLevel}x, pan offset: (${currentPanOffset.x}, ${currentPanOffset.y})`);
    
    // Apply a CSS transform to the canvas element itself to ensure zoom/pan is visually applied
    if (canvasComponent.value?.canvasRef?.value) {
      // Force browser to recognize the transform change
      void canvasComponent.value.canvasRef.value.offsetHeight;
    }
  
  if (annotations && annotations.length > 0) {
      // Draw each annotation
      annotations.forEach(annotation => {
        // Set style based on selection state
        const isSelected = annotationSelection.selectedAnnotationIds.value.includes(annotation._id);
        const isHighlighted = annotationSelection.highlightedAnnotationId.value === annotation._id;
        const isHovered = annotationEdit.hoveredAnnotationId?.value === annotation._id;
        
        // Different styles for different states
        ctx.lineWidth = isSelected || isHighlighted ? 3 : 2;
        ctx.strokeStyle = isSelected ? '#00FF00' : 
                          isHighlighted ? '#FFFF00' : 
                          isHovered ? '#00AAFF' : 
                          getColorForClass(annotation.label);
        
        // Get annotation original coordinates
        const x = annotation.x;
        const y = annotation.y;
        const width = annotation.width;
        const height = annotation.height;        // Annotations are stored in image space coordinates and need to be 
        // converted to screen space for display with the current zoom/pan settings
        
        // Use consistent transformation utility function with the correct direction
        const screenCoords = transformCoordinates(
          { x, y, width, height },
          zoomPan.zoomLevel.value,
          zoomPan.panOffset.value,
          'imageToScreen'
        );
        
        // Draw the annotation rectangle in screen space
        ctx.strokeRect(
          screenCoords.x,
          screenCoords.y,
          screenCoords.width,
          screenCoords.height
        );
        
        // Draw label if present
        if (annotation.label) {
          ctx.font = '12px Arial';
          ctx.fillStyle = ctx.strokeStyle;
          ctx.fillText(annotation.label, screenCoords.x, screenCoords.y - 5);
        }
        
        // For debugging
        console.log(`Drew annotation "${annotation.label}" (id: ${annotation._id}) at:`, {
          imageSpace: { x, y, width, height },
          screenSpace: screenCoords,
          zoom: zoomPan.zoomLevel.value,
          pan: zoomPan.panOffset.value
        });
      });
    }    // Draw any in-progress drawing rectangle
    if (annotationDraw.drawing.value && annotationDraw.currentRectRaw.value) {
      ctx.strokeStyle = '#00AAFF';
      ctx.lineWidth = 2;
      
      const rawRect = annotationDraw.currentRectRaw.value;
      
      // We can draw the in-progress rectangle directly without transformation
      // because currentRectRaw already contains screen coordinates
      // Only when finishing the drawing do we transform to image coordinates (in finishDrawing)
      ctx.strokeRect(
        rawRect.x,
        rawRect.y,
        rawRect.width,
        rawRect.height
      );
      
      console.log('Drawing in-progress rectangle in screen space:', rawRect);
    }
  } catch (error) {
    console.error('Error in redrawCanvas:', error);
  }
}

// Initialize canvas coordinates functionality
const canvasCoordinates = useCanvasCoordinates();

// Initialize zoom & pan functionality
const zoomPan = useZoomPan(canvasCoordinates, redrawCanvas);

// Initialize annotation functionalities
const annotationDraw = useAnnotationDraw(canvasComponent, projectId, imageId, annotationStore, toast, zoomPan, redrawCanvas);
const annotationEdit = useAnnotationEdit(canvasComponent, annotationStore, toast, zoomPan, redrawCanvas);
const annotationHistory = useAnnotationHistory(projectId, imageId, annotationStore, redrawCanvas);
const annotationSelection = useAnnotationSelection(projectId, imageId, annotationStore, toast, redrawCanvas);

// Initialize detection functionality
const detection = useDetection(projectId, imageId, annotationStore, toast, redrawCanvas);

// Define functions that are referenced in the template but not initialized above
// For class handling
const currentClassName = ref('');
const showClassModal = ref(false);

function getColorForClass(className) {
  // Simple hash function to generate colors based on class name
  let hash = 0;
  for (let i = 0; i < className.length; i++) {
    hash = className.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash % 360);
  return `hsl(${hue}, 70%, 50%)`;
}

function selectClass(className) {
  currentClassName.value = className;
}

function confirmClassInput(className) {
  currentClassName.value = className;
  showClassModal.value = false;
}

function cancelClassInput() {
  showClassModal.value = false;
}

function onImageLoaded() {
  console.log('Image loaded successfully');
}

function onImageLoadError() {
  console.error('Failed to load image');
  toast.error('Failed to load image');
}

function onImportComplete(annotations) {
  toast.success(`Imported ${annotations.length} annotations`);
  redrawCanvas();
}

/**
 * Debug function to test coordinate transformations with real annotations
 * Call from browser console: debugCoordinateTransform()
 */
window.debugCoordinateTransform = function() {
  // Import the test function
  import('../../utils/annotationUtils').then(({ testCoordinateTransform }) => {
    console.log('STARTING COORDINATE TRANSFORMATION TESTS');
    
    // Test with current annotations if available
    if (annotationStore.currentAnnotations && annotationStore.currentAnnotations.length > 0) {
      const annotation = annotationStore.currentAnnotations[0];
      console.log('Testing with real annotation:', annotation);
      
      const coords = { 
        x: annotation.x, 
        y: annotation.y, 
        width: annotation.width, 
        height: annotation.height 
      };
      
      // Test with current zoom and pan
      testCoordinateTransform(
        coords,
        zoomPan.zoomLevel.value,
        zoomPan.panOffset.value
      );
    } else {
      console.log('No annotations available, using sample values');
      
      // Use sample values
      const sampleCoords = { x: 100, y: 100, width: 50, height: 50 };
      
      // Test with current zoom and pan
      testCoordinateTransform(
        sampleCoords,
        zoomPan.zoomLevel.value,
        zoomPan.panOffset.value
      );
    }
    
    console.log('COORDINATE TRANSFORMATION TESTS COMPLETE');
  });
};

// Initialize all composables - this must be done before they're used in the template
// Initialize coordinate system
const zoomPan = useZoomPan();
const canvasCoordinates = useCanvasCoordinates(zoomPan);

// Initialize annotation functionalities
const annotationDraw = useAnnotationDraw(canvasComponent, projectId, imageId, annotationStore, toast, zoomPan, redrawCanvas);
const annotationEdit = useAnnotationEdit(canvasComponent, annotationStore, toast, zoomPan, redrawCanvas);
const annotationHistory = useAnnotationHistory(projectId, imageId, annotationStore, redrawCanvas);
const annotationSelection = useAnnotationSelection(projectId, imageId, annotationStore, toast, redrawCanvas);

// Initialize detection functionality
const detection = useDetection(projectId, imageId, annotationStore, toast, redrawCanvas);

// Initialize tag management functionality
const tagManagement = useTagManagement();

// Define functions that are referenced in the template but not initialized above
// For class handling
const currentClassName = ref('');
const showClassModal = ref(false);

function getColorForClass(className) {
  // Simple hash function to generate colors based on class name
  let hash = 0;
  for (let i = 0; i < className.length; i++) {
    hash = className.charCodeAt(i) + ((hash << 5) - hash);
  }
  const hue = Math.abs(hash % 360);
  return `hsl(${hue}, 70%, 50%)`;
}

function selectClass(className) {
  currentClassName.value = className;
}

function confirmClassInput(className) {
  currentClassName.value = className;
  showClassModal.value = false;
}

function cancelClassInput() {
  showClassModal.value = false;
}

function onImageLoaded() {
  console.log('Image loaded successfully');
}

function onImageLoadError() {
  console.error('Failed to load image');
  toast.error('Failed to load image');
}

function onImportComplete(annotations) {
  toast.success(`Imported ${annotations.length} annotations`);
  redrawCanvas();
}
</script>
