<template>
  <!-- Keeping original template structure -->
  <div class="annotation-editor-view">
    <!-- Breadcrumb and UI elements remain unchanged -->
    <!-- Other UI components remain unchanged -->
  </div>
</template>

<script setup>
/* 
 * IMPORTANT NOTE ABOUT ANNOTATION WORKFLOW:
 * 
 * The backend endpoint used for creating annotations `/api/annotations/image/:imageId/set` first DELETES ALL
 * existing annotations for the image before saving the new ones. This means:
 * 
 * 1. Creating a new annotation will remove all previous annotations for that image on the server
 * 2. If the frontend store isn't updated correctly, there can be a mismatch between UI state and server state
 * 3. This can lead to 404 errors when trying to delete annotations that appear in the UI but no longer exist on the server
 * 
 * The annotationStore.js has been adjusted to replace the local annotations array with the server response
 * after creation, and improved error handling for the delete operation.
 */

// Importing everything needed for the component
import { ref, onMounted, computed, watch, nextTick, onUnmounted } from 'vue';
import { useRoute, useRouter } from 'vue-router';
import { useProjectStore } from '../store/projectStore';
import { useImageStore } from '../store/imageStore';
import { useAnnotationStore } from '../store/annotationStore';

// The key fixes in this file will be:
// 1. Properly maintaining chronological order in undo/redo stacks
// 2. Making sure timestamps are preserved correctly between stacks
// 3. Using debouncedRefreshAnnotations consistently to ensure UI/backend sync
// 4. Preserving class and color information across undo/redo operations 
// 5. Properly handling edge cases when annotations no longer exist

// Routes and stores
const route = useRoute();
const router = useRouter();

const projectStore = useProjectStore();
const imageStore = useImageStore();
const annotationStore = useAnnotationStore();

// Rest of your state variables and component logic

// Undo/Redo state
const undoStack = ref([]);
const redoStack = ref([]);
const MAX_UNDO_HISTORY = 20; // Maximum number of actions in the undo history
const undoLimitReached = ref(false); // Flag to indicate if the undo history limit has been reached

const canUndo = computed(() => undoStack.value.length > 0);
const canRedo = computed(() => redoStack.value.length > 0);

// Function to add an action to the undo stack and manage its size
function addToUndoStack(action) {
  // Ensure action has a timestamp
  if (!action.timestamp) {
    action.timestamp = Date.now();
  }
  
  // Add action to the end of the stack (newest actions at the end)
  undoStack.value.push(action);
  undoLimitReached.value = false;
  
  // We no longer sort the stack - instead we rely on the natural order of actions
  // being added to the stack chronologically, which is more reliable for undo/redo
  
  // If we exceed the maximum history size, remove the oldest action
  if (undoStack.value.length > MAX_UNDO_HISTORY) {
    undoStack.value.shift(); // Remove the oldest action (at index 0)
    undoLimitReached.value = true;
    console.log(`Undo history limit reached (${MAX_UNDO_HISTORY} actions). Oldest action removed.`);
  }
  
  // Clear the redo stack when a new action is performed
  redoStack.value = [];
  
  console.log(`Added to undo stack: ${action.type} action with ID ${action.annotationId || (action.annotationData && action.annotationData._id) || 'unknown'}`);
}

// Variables for debounced refresh
let refreshTimeout = null;
const REFRESH_DELAY = 300; // milliseconds

// Function to refresh annotations with debouncing
async function debouncedRefreshAnnotations() {
  // Clear any existing timeout
  if (refreshTimeout) {
    clearTimeout(refreshTimeout);
  }
  
  // Set a new timeout
  refreshTimeout = setTimeout(async () => {
    console.log("Performing debounced refresh of annotations");
    await annotationStore.fetchAnnotations(imageId.value);
    refreshTimeout = null;
  }, REFRESH_DELAY);
}

// Debug helper function to log undo/redo stacks
function logStackState() {
  console.log('==== UNDO/REDO STACK STATE ====');
  console.log(`Undo stack (${undoStack.value.length}):`, undoStack.value.map(a => `${a.type} @ ${new Date(a.timestamp).toISOString().substr(11, 8)}`));
  console.log(`Redo stack (${redoStack.value.length}):`, redoStack.value.map(a => `${a.type} @ ${new Date(a.timestamp).toISOString().substr(11, 8)}`));
  console.log('==============================');
}

async function undo() {
  if (!canUndo.value) return;
  
  logStackState(); // Log stack state before undo
  
  // Get the most recent action (from the end of the stack)
  const action = undoStack.value.pop();
  console.log("Undoing action:", action.type, "with timestamp:", new Date(action.timestamp).toISOString());

  try {
    if (action.type === 'CREATE') {
      // Undo creation means deleting the annotation
      const annotationId = action.annotationId;
      
      // Check if the annotation still exists before trying to delete it
      const annotationExists = annotationStore.currentAnnotations.some(ann => ann._id === annotationId);
      if (!annotationExists) {
        console.warn(`Cannot undo creation: annotation with ID ${annotationId} no longer exists`);
        // Make sure UI is updated by refreshing annotations from server
        await debouncedRefreshAnnotations();
        return;
      }
      
      // Save a copy of the annotation data before deleting (for redo)
      const annotationToDelete = annotationStore.currentAnnotations.find(ann => ann._id === annotationId);
      if (!annotationToDelete) {
        console.error("Annotation not found in store despite existing check passing");
        return;
      }
      
      const annotationDataCopy = JSON.parse(JSON.stringify(annotationToDelete));
      
      const success = await annotationStore.deleteAnnotation(annotationId, imageId.value, projectId.value);
      if (success) {
        console.log("Successfully deleted annotation during undo");
        
        // Store the complete annotation data for potential redo
        redoStack.value.push({
          type: 'CREATE',
          annotationData: annotationDataCopy,
          timestamp: action.timestamp // Preserve the original timestamp
        });
        
        // Make sure UI is updated by refreshing annotations from server
        await debouncedRefreshAnnotations();
      } else {
        // Push back if failed - at the end of the stack to maintain chronological order
        undoStack.value.push(action);
        alert("Undo failed: Could not delete the annotation.");
        
        // Refresh annotations from server to ensure UI is in sync
        await debouncedRefreshAnnotations();
      }
    } else if (action.type === 'DELETE') {
      // Undo deletion means re-creating the annotation
      // Ensure _id is not part of the data sent for creation
      const { _id, ...dataToRecreate } = action.annotationData;
      
      // Preserve the original class and color
      const className = dataToRecreate.label;
      console.log("Recreating deleted annotation with class:", className);
      
      // Ensure the color matches the class
      dataToRecreate.color = getColorForClass(className);
      
      const newAnnotation = await annotationStore.createAnnotation(imageId.value, dataToRecreate, projectId.value);
      if (newAnnotation && newAnnotation._id) {
        console.log("Successfully recreated annotation with ID:", newAnnotation._id);
        
        // For redo, we need to know the ID of the annotation that was just re-created to delete it again
        redoStack.value.push({ 
          type: 'DELETE', 
          timestamp: action.timestamp, // Preserve the original timestamp
          annotationData: { 
            ...dataToRecreate, 
            _id: newAnnotation._id,
            color: newAnnotation.color || dataToRecreate.color,
            label: className // Ensure class info is preserved 
          } 
        });
        
        // Make sure UI is updated
        await debouncedRefreshAnnotations();
      } else {
        undoStack.value.push(action); // Push back if failed
        alert("Undo failed: Could not re-create the annotation.");
        await debouncedRefreshAnnotations();
      }
    } else if (action.type === 'UPDATE') {
      // Undo update means reverting to oldData
      const annotationId = action.annotationId;
      
      // Check if the annotation still exists
      const annotationExists = annotationStore.currentAnnotations.some(ann => ann._id === annotationId);
      if (!annotationExists) {
        console.warn(`Cannot undo update: annotation with ID ${annotationId} no longer exists`);
        // Instead of trying to update, we should recreate the annotation using oldData
        const { _id, ...dataToRecreate } = action.oldData;
        console.log("Recreating annotation instead of updating");
        
        const reCreatedAnnotation = await annotationStore.createAnnotation(imageId.value, dataToRecreate, projectId.value);
        if (reCreatedAnnotation && reCreatedAnnotation._id) {
          console.log("Successfully recreated annotation with ID:", reCreatedAnnotation._id);
          
          // For redo, we need to use the new ID
          redoStack.value.push({ 
            type: 'DELETE',
            timestamp: action.timestamp, // Preserve the original timestamp
            annotationData: { 
              ...dataToRecreate, 
              _id: reCreatedAnnotation._id,
              color: reCreatedAnnotation.color || dataToRecreate.color,
              label: dataToRecreate.label // Ensure class info is preserved
            } 
          });
          
          // Ensure UI state is in sync with backend
          await debouncedRefreshAnnotations();
        } else {
          alert("Undo failed: Could not recreate the annotation to its previous state.");
          // Ensure UI state is in sync with backend
          await debouncedRefreshAnnotations();
        }
        return;
      }
      
      // Normal update flow if annotation exists
      const { _id, ...updatePayload } = action.oldData;
      const success = await annotationStore.updateAnnotation(annotationId, updatePayload, projectId.value, imageId.value);
      if (success) {
        console.log("Successfully updated annotation during undo");
        
        // For redo, we need to push an UPDATE action with oldData being current (action.oldData) and newData being action.newData
        redoStack.value.push({
          type: 'UPDATE',
          annotationId: annotationId,
          timestamp: action.timestamp, // Preserve the original timestamp
          oldData: action.oldData,
          newData: action.newData
        });
        
        // Update originalAnnotationBeforeEdit to reflect the undone state if user continues editing
        if (editingAnnotationId.value === annotationId) {
          originalAnnotationBeforeEdit.value = JSON.parse(JSON.stringify(action.oldData));
        }
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
      } else {
        undoStack.value.push(action);
        alert("Undo failed: Could not update the annotation to its previous state.");
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
      }
    }
  } catch (error) {
    console.error("Error occurred during undo operation:", error);
    // Push the action back to the stack if there was an error
    undoStack.value.push(action);
    alert("An error occurred during the undo operation. Please try again.");
    
    // Make sure UI is in sync with the backend
    await debouncedRefreshAnnotations();
  }
  
  // Log stack state after undo
  logStackState();
}

async function redo() {
  if (!canRedo.value) return;
  
  logStackState(); // Log stack state before redo
  
  const action = redoStack.value.pop();
  console.log("Redo action:", action.type, "with timestamp:", new Date(action.timestamp).toISOString());

  try {
    if (action.type === 'CREATE') { // Redo creation
      // The annotationData in a CREATE action on redoStack is the one that was originally created.
      // We need to remove its _id if it's there, as createAnnotation expects data without an _id.
      const { _id, ...dataToRecreate } = action.annotationData;
      
      // Preserve the original class and color
      const className = dataToRecreate.label;
      console.log("Recreating annotation with class:", className);
      
      // Make sure to set the color to match the original class
      dataToRecreate.color = getColorForClass(className);
      
      // Create a new annotation using the original data
      const reCreatedAnnotation = await annotationStore.createAnnotation(imageId.value, dataToRecreate, projectId.value);
      if (reCreatedAnnotation && reCreatedAnnotation._id) {
        console.log("Successfully recreated annotation with ID:", reCreatedAnnotation._id);
        
        // Make sure UI is updated
        await debouncedRefreshAnnotations();
        
        // Push new CREATE action to undo stack with the new ID
        undoStack.value.push({ 
          type: 'CREATE', 
          annotationId: reCreatedAnnotation._id,
          timestamp: action.timestamp, // Preserve the original timestamp
          annotationData: { 
            ...dataToRecreate, 
            color: reCreatedAnnotation.color || dataToRecreate.color, 
            _id: reCreatedAnnotation._id,
            label: className // Ensure class info is preserved
          }
        });
      } else {
        redoStack.value.push(action); // Push back if failed
        alert("Redo failed: Could not re-create the annotation.");
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
      }
    } else if (action.type === 'DELETE') { // Redo deletion
      // The annotationData in a DELETE action on redoStack contains the _id of the annotation to be deleted.
      const annotationId = action.annotationData._id;
      
      // Verify that the annotation exists before trying to delete it
      const annotationExists = annotationStore.currentAnnotations.some(ann => ann._id === annotationId);
      if (!annotationExists) {
        console.warn(`Cannot redo deletion: annotation with ID ${annotationId} no longer exists`);
        // Skip this action since the annotation is already gone
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
        return;
      }
      
      // Save a copy of the annotation data before deleting (for undo)
      const annotationToDelete = annotationStore.currentAnnotations.find(ann => ann._id === annotationId);
      if (!annotationToDelete) {
        console.error("Annotation not found in store despite existing check passing");
        return;
      }
      
      const annotationDataCopy = JSON.parse(JSON.stringify(annotationToDelete));

      const success = await annotationStore.deleteAnnotation(annotationId, imageId.value, projectId.value);
      if (success) {
        console.log("Successfully deleted annotation during redo");
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
        
        // Push to undo stack with timestamp preserved
        undoStack.value.push({ 
          type: 'DELETE',
          timestamp: action.timestamp, // Preserve the original timestamp
          annotationData: annotationDataCopy
        });
      } else {
        redoStack.value.push(action); // Push back if failed
        alert("Redo failed: Could not delete the annotation.");
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
      }
    } else if (action.type === 'UPDATE') {
      // Redo update means applying newData
      const annotationId = action.annotationId;
      
      // Check if the annotation still exists
      const annotationExists = annotationStore.currentAnnotations.some(ann => ann._id === annotationId);
      if (!annotationExists) {
        console.warn(`Cannot redo update: annotation with ID ${annotationId} no longer exists`);
        // Instead of trying to update, we should recreate the annotation
        const { _id, ...dataToRecreate } = action.newData;
        console.log("Recreating annotation instead of updating");
        
        const reCreatedAnnotation = await annotationStore.createAnnotation(imageId.value, dataToRecreate, projectId.value);
        if (reCreatedAnnotation && reCreatedAnnotation._id) {
          console.log("Successfully recreated annotation with ID:", reCreatedAnnotation._id);
          
          // Make sure UI is updated
          await debouncedRefreshAnnotations();
          
          // Push new CREATE action to undo stack
          undoStack.value.push({ 
            type: 'CREATE', 
            annotationId: reCreatedAnnotation._id,
            timestamp: action.timestamp, // Preserve the original timestamp
            annotationData: { 
              ...dataToRecreate, 
              _id: reCreatedAnnotation._id,
              color: reCreatedAnnotation.color || dataToRecreate.color,
              label: dataToRecreate.label // Ensure class info is preserved
            } 
          });
        } else {
          alert("Redo failed: Could not recreate the updated annotation.");
          
          // Ensure UI state is in sync with backend
          await debouncedRefreshAnnotations();
        }
        return;
      }
      
      // Normal update flow if annotation exists
      const { _id, ...updatePayload } = action.newData;
      const success = await annotationStore.updateAnnotation(annotationId, updatePayload, projectId.value, imageId.value);
      if (success) {
        console.log("Successfully updated annotation during redo");
        
        // Make sure UI is updated
        await debouncedRefreshAnnotations();
        
        // Push the original UPDATE action to undo with its timestamp preserved
        undoStack.value.push({ 
          type: 'UPDATE', 
          annotationId: annotationId,
          timestamp: action.timestamp, // Preserve the original timestamp
          oldData: action.oldData,
          newData: action.newData
        });
        
        // Update originalAnnotationBeforeEdit to reflect the redone state if user continues editing
        if (editingAnnotationId.value === annotationId) {
          originalAnnotationBeforeEdit.value = JSON.parse(JSON.stringify(action.newData));
        }
      } else {
        redoStack.value.push(action); // Push back if failed
        alert("Redo failed: Could not update the annotation to its next state.");
        
        // Ensure UI state is in sync with backend
        await debouncedRefreshAnnotations();
      }
    }
  } catch (error) {
    console.error("Error occurred during redo operation:", error);
    // Push the action back to the stack if there was an error
    redoStack.value.push(action);
    alert("An error occurred during the redo operation. Please try again.");
    
    // Make sure UI is in sync with the backend
    await debouncedRefreshAnnotations();
  }
  
  // Log stack state after redo
  logStackState();
}

// Rest of your component logic
</script>

<style scoped>
/* Your style rules remain unchanged */
</style>
